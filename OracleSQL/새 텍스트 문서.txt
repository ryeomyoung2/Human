create table student(
name varchar2(32)not null,
gender char(1) default 'F'
);
insert into student(name) values('james');
insert into student values('john','m');
select * from student;

결과

name 	| gender
-------------------
james	| F
john	| m

===> default 문으로 젠더추가 안해놓으면 F로 자동으로 출력되는 것을 확인할 수 있음.


-----------------------------------------------------------------------------------------------------------------------------------------------------

drop table 테이블명 ==>테이블 삭제하기 1(데이터도 다 날아감,   스키마+데이터)   
truncate table 테이블명 ==>이건 데이터만 다날아간다. 테이블은 남아있음

schema(스키마)


-유저가 만든 테이블리스트 전부 조회 select table_name from user_tables;

-테이블명 수정  rename student to sts; (테이블명을 student에서 sts로 수정)

-컬럼이름/타입/길이 (Oracle SQL)
alter table 테이블명 add 새컬럼명 타입(길이)  ==>새 컬럼추가

alter table 테이블명 drop column 기존 컬럼명 ==>기존컬럼 이름변경

alter table 테이블명 rename column 컬럼명 to 새컬럼명 ==>기존컬럼 이름변경(타입은 그대로임)

alter table 테이블명 modify 기존컬럼명 새타입(새길이) ==>기존컬럼 타입이랑 길이변경


-컬럼이름/타입/길이 (MySQL)
alter table 테이블명 change 컬럼명 새컬럼명 새타입(새길이) ==>기존컬럼 이름,타입,길이 변경하는법 (안바꿀것은 그대로 냅두면됨)

	|data(DML)	|metadata(DDL)
-----------------------------------------------------	
create	|insert		|create
read	|select		|select
update	|update		|alter
delete	|delete		|drop,truncate


DCL문(data control language)

-grant dba to ora_user
 revoke dba to ora_user

-rollback
 commit

------------------------------------------------------------------------------------------------------------------
*insert문 문법

     (oracle sql)

1.   insert into 테이블명 values(값1,.......,값n)
2.   insert into 테이블명 (컬럼명1,....,컬럼명n) values(값1,....,값n)

     (mysql)

     insert into 테이블명 set 컬럼명1=값1,...,컬럼명n=값n


create table student(
name varchar2(12) not null,
gender char(1) default 'f',
birthday char(8) default '00000000',
mobile varchar2(12),
area varchar2(20),
english number(3) default 0,
math number(3) default 0,
korean number(3) default 0
);
insert into student values('john','M','199604**','4133****','seoul',90,80,70);  //위 방법으로 데이터넣기
insert into student (name, mobile,area)values('james','4133****','seoul');  // 디폴트 제외한것만 넣기


------------------------------------------------------------------------------------------------------------------
*delete문 문법

delete from 테이블명 where 조건문[컬럼명 비교연산자 값]
	ㄴdelete from student where name='john'   이렇게하면 존만 지워짐 다 지워버리고싶으면 
 					    delete from student 하면됨					

------------------------------------------------------------------------------------------------------------------
*update문 문법

update 테이블명 set 컬럼명1=값1,...,컬럼명n=값n where 조건문[컬럼명 비교연산자 값]
	ㄴupdate student set math=100; 이렇게하면 전부 수학점수가 100점으로 업데이트

	ㄴupdate student set math=100, english=96, korean=72 where name='james';
	   제임스의 점수 업데이트

update student set gender='M' where gender is null  (예외적으로 null을 업데이트하고싶을땐 =가 아닌 is를 쓴다)
------------------------------------------------------------------------------------------------------------------
*select문 문법

select 컬럼명1,....,컬럼명n from 테이블명1,...,테이블명n
	ㄴselect * from student  (student 테이블의 모든 컬럼을 읽어서 보여달라는 뜻)
	
	* ==> 모든 컬럼들

	ㄴselect name from student    (student테이블의 이름만 조회)

------------------------------------------------------------------------------------------------------------------
테이블 복사

create table sts as select * from student;  (stduent테이블을 sts라는 이름의 테이블로 하나 더 복사)
------------------------------------------------------------------------------------------------------------------
뷰


view:복잡한 조건의 select문이 반복적으로 사용될 때, 번거로움을 줄여주기 위해 사용

1. create view 뷰이름 as select 컬럼명1,...,컬럼명n from 테이블1,...,테이블n where 조건문
2. create or replace view 뷰이름 as select 컬럼명1,...,컬럼명n from 테이블1,...,테이블n where 조건문


 

create view worker as select emp_name, salary from employees where hire_data>20/12/31 and salary<=10000
다른부서가 특정 조건 employees의 일부만(20/12/31일 이후 입사했고 봉급이 10000이하인사람중 이름이랑 봉급만) 열람할 수 있게 할때 씀
select * from worker 로 조회가능

create or replace view worker as select emp_name, salary from employees 
있으면 고치고 없으면 새로만들기

drop view 뷰이름; (뷰 삭제)

select view_name from user_views; (만들었던 뷰 조회)
------------------------------------------------------------------------------------------------------------------

index : data의 검색속도를 빠르게 하기위해 사용

인덱스 생성
create index 인덱스명 on 테이블명(컬럼명1,...,컬럼명n)
create or replace index 인덱스명 on 테이블명(컬럼명1,...,컬럼명n)

ex)    create or replace index ndx_name on student(name)

drop index 인덱스명   (인덱스삭제)
select index_name form user_indexes (인덱스 조회)

------------------------------------------------------------------------------------------------------------------
시노님:데이터테이블의 별명 붙여주기

1. create synonym 별명 for 테이블명
2. create or replace synonym 별명 for 테이블명

drop synonym 별명 (시노님 삭제)

------------------------------------------------------------------------------------------------------------------
시퀀스 sequence : 일련번호 자동생성기(number generator)

create sequence 시퀀스명 start with 1 increment by 1  =>시퀀스생성

시퀀스명.nextval       => 새 시퀀스 번호 가져오기 (사용될때마다 증가한다)

select 시퀀스명.currval from dual    =>마지막 시퀀스 번호 확인



create sequence seq_mid start with 1 increment by 1;            =>시퀀스생성
insert into student values(seq_mid.nextval,'john');
select * from student;
insert into student values(seq_mid.nextval,'james');
insert into student values(seq_mid.nextval,'johanson');
insert into student values(seq_mid.nextval,'jacob');
select seq_mid.currval from dual;			 =>마지막 시퀀스 번호 확인


mysql에서는 시퀀스 안쓰고 아래처럼 쓴다.

create table student (
mid number auto_increment,
name varchar(12)
)

insert into student set name='john';
------------------------------------------------------------------------------------------------------------------
머지

merge: 조건에 맞는 데이터가 없으면 insert, 있으면 update 수행
(mysql의 replace와 비슷, 실무에선 잘 안씀)
------------------------------------------------------------------------------------------------------------------
drop table           schema+data 둘다 날아가고 복구불능
truncate table      data만 날아감, 복구불능
delete from         data만 날아감, 복구가능(rollback)

select * from student;
commit;     -확정
delete from student;
rollback;     -되돌리기
이렇게하면 커밋 이후까지만 롤백가능

------------------------------------------------------------------------------------------------------------------
의사칼럼

select rownum,rowid,employee_id,emp_name from employees; 했을때는 나오지만
select * from employees; 할때는 안나오는 컬럼
------------------------------------------------------------------------------------------------------------------
연산자
-산술연산자  +, -, *(asterisk), /, ||(문자열 연결 연산자)

-비교연산자 =, !=, <>, >, <, >=, <=  
컬럼명 is null, 컬럼명 is not null
select * from employees where salary is not null;    =>null아닌것 조회

-논리연산자 and,or,not
select emp_name,salary,hire_date from employees where salary<5000 and hire_date < '05/01/01';

-집합연산자(sql문에만) union/union all(합집합), intesect(교집합), minus(차집합)



select 3+5 from dual; (오라클sql)
select 3+5;  (mysql)
select salary, salary*1.1 from employees; =>곱하기 연산자로 10%인상한 봉급 보기
select emp_name,salary from employees where salary*2>10000;   
=>봉급2배로 올려주면 10000보다 커지는사람 조회

select '['||emp_name||']' from employees; 입력하면

[Donald OConnell]
[Douglas Grant]
[Jennifer Whalen] 

이런식으로 나옴

select employee_id,emp_name,salary from employees where salary>=5000 and salary<10000;
=>월급이 5000불이상 10000불미만 사번,이름,월급

select * from employees where manager_id is null;
=>매니저 아이디를 갖고있지 않는, 즉 사장 찾기


select emp_name from employees where manager_id =100;
=>매니저 아이디가 사장의 사번인 사람 아이디 찾기(사장직속부하직원 찾기)
------------------------------------------------------------------------------------------------------------------
표현식

case when 조건1 then 값1 when 조건2 then 값2 else 값 end
=> 반드시 select안에만 사용(where에서 사용 안함)

	 select employee_id, salary,
	 case when salary<=5000 then '   c' 
	 when salary>=5000 and salary<=10000 then '   b' 
	 else '   a'
	 end as grade from employees;

컬럼명 as aliasname     (aliasname=synonym같은 개념)

not(salary>=2500)   => salary < 2500
not salary>4000

select salary from employees where not salary>10000

컬럼명 between 값A and 값B  => 컬럼명>=값a and 컬럼명<= 값B

salary between 5000 and 10000  => salary>=5000 and salary<=10000

컬럼명 in(값1,....,값n)  == 
컬럼명=값1 or ....or 컬럼명=값n == 
컬럼명 =any(값1,...,값n)

셋다 같음


ex) select emp_name,salary from employees where salary between 5800 and 7000;
ex) select emp_name,salary from employees where salary in(3000,4000,5000,6000,7000);
ex) select emp_name,salary from employees where salary=any(3000,4000,5000,6000,7000);
ex) select emp_name,salary from employees where salary=some(3000,4000,5000,6000,7000);


name like 'a_'    a로 시작하는 두글자 찾기
name like 'a__'  a로 시작하는 세글자 찾기
name like 'a_d__'  a로 시작하고 중간에 d가 포함된 5글자 찾기
name like 'J%'   J로 시작하는 모든 문장 찾기(대소문자구분해야됨)
name like '%son' son으로 끝나는 모든 문장 찾기

select emp_name from employees order by emp_name;
abcde...순으로 이름찾기

select emp_name from employees where emp_name like'John%';
이름이 존으로 시작하는 모든사람 찾기
select emp_name from employees where emp_name like'%son';
성이 son으로 끝나는 모든 사람 찾기
select emp_name from employees where emp_name like'%son %';
이름이 son으로 끝나는 모든 사람 찾기
select emp_name from employees where emp_name like'% S%';
성이 s로 시작하는 모든 사람 찾기
select emp_name from employees where emp_name like'%Y%' or emp_name like'%y%';
이름 전체에서  Y,y가 들어가는 모든 사람 찾기






숫자함수

abs절댓값

select abs(-3.14) from dual;  =>결과 3.14
select * from employees where abs(salary)>3000 => 샐러리의 절대값이 3천보다 큰 사람 찾기

--------------------------------------------------------------------------------------------------------------


celi() : 큰 숫자 중 가장 작은 정수 찾기

ceil(3.14)  => 4

floor() : 작은 숫자 중 가장 큰 정수 찾기

floor(3.14) => 3
--------------------------------------------------------------------------------------------------------------

power(): 거듭제곱

ex) power(2,3) => 2*2*2

sqrt(): 제곱근

ex) sqrt(16) => 4

mod()/remainder() : 나머지

select mod(19,4),remainder(19,4) from dual;    =>모드는 제대로 나머지가 3이 나오지만
리메인더는 통상적으로 쓰이는 나머지가 안구해져서 잘 안씀

log(10,100) => 2
--------------------------------------------------------------------------------------------------------------

initcap

select initcap('park jae hyung') from dual; => 앞글자를 대문자로
select lower('pARk jae hyung') from dual; => 전부  소문자로
select upper('pARk jae hyung') from dual => 전부 대문자로

concat => concatenation(문자열 연결) == ||  (mysql에서는 +)

select concat(concat('Good ','Morning'), ' Vietnam') from dual; 이렇게쓰지말고
select 'Good '||'Morning '||'Vietnam' from dual; 이거쓸것


substr => substring(부분문자열)

substr(문자열/컬럼명,시작인덱스,[길이])

select substr('Good Morning',1,4) from dual; => 'Good' 출력 여기서 4를 생략하면 끝까지 출력

select substr('Good Morning',-7) from dual; => 오른쪽부터 -1 -2 -3... 해서 Morning만 출력

select substr(emp_name,1,5) from employees; 전체직원들의 이름을 앞에서 5글자까지만 출력


instr :어떤문자열이 어디서부터 (인덱스) 나타나는지 찾기 , 못찾으면 0나옴
ex) select instr('Good Morning','Morning') from dual=> 6

select emp_name,instr(emp_name,' ')from employees;  => 직원들이름중 공백있는부분이 몇번째인덱스인지 모두 출력

select emp_name, substr(emp_name,1,instr(emp_name,' ')-1) from employees; 

=> instr  와 substr를 활용해서 직원들의 이름만 추출하기

select emp_name, substr(emp_name,instr(emp_name,' ')+1) from employees;

=> instr  와 substr를 활용해서 직원들의 성만 추출하기
--------------------------------------------------------------------------------------------------------------

select ltrim('          world        ')from dual; =>왼쪽공백이 다 짤림
select rtrim('          world        ')from dual; =>오른쪽공백이 다 짤림
select trim('          world        ')from dual; =>공백이 다 짤림

--------------------------------------------------------------------------------------------------------------
replace : 문자열에서 부분문자열을 다른 문자열로 대치한다.

replace(문자열,대상문자열,목표문자열)

select replace('Good Morning','Morning','Evening')from dual;  =>굿모닝이 굿이브닝으로 변경되어 출력

select replace(phone_number,'.','-')from employees; =>전화번호에서 .를 -로 대치에서 출력

substr,instr,replace ,|| 이 네개가 제일 많이 쓰임
--------------------------------------------------------------------------------------------------------------
length :문자열 길이구하기

length(문자열/컬럼명)

select emp_name,length(emp_name)from employees;
=>직원 이름 길이 출력

select length('홍길동'),lengthb('홍길동')from dual;    => length는 3나오고 lengthb는 bite기때문에 6나옴
--------------------------------------------------------------------------------------------------------------
lpad/rpad(문자열/컬럼명,전체길이,채울문자열)

select lpad('World',20,' ')from dual; => 20칸중에 world 5칸 빼고 왼쪽 15개 전부 공백으로채움
select rpad('World',20,'9')from dual; => 20칸중에 world 5칸 빼고 오른쪽 15개 전부 공백으로채움

--------------------------------------------------------------------------------------------------------------

sysdate - 오늘날짜
systimestamp -현재시각

select sysdate,systimestamp from dual;

--------------------------------------------------------------------------------------------------------------
to_char(숫자/날짜) =>문자열로 출력

select to_char(sysdate,'YYYY-MM-DD')from dual; => 2022-09-08
select to_char(sysdate,'YY.MM.DD')from dual; =>22.09.08
select to_char(systimestamp,'YYYY-MM-DD HH:MI:SS')from dual; => 2022-09-08 11:23:10

to_number(문자열) =>숫자로 출력

select to_number('1234')from dual;  => 1234
--------------------------------------------------------------------------------------------------------------
NVL(칼럼명,칼럼과 같은타입의 값) : 칼럼값이 null아니면, 그 칼럼값 출력
		 칼럼값이 null이면 대신 입력한 값을 출력

select emp_name,nvl(manager_id,0)from employees; 사장만 null이므로 0으로 변환되어 출력

NVL2(칼럼명,값1,값2): 칼럼값이 null이면 값1출력
		  칼럼값이 null아니면 값2출력

select emp_name,manager_id,NVL2(manager_id,1,0)from employees; 
매니저아이디가 null이면 0찍고 아니면 1 출력

--------------------------------------------------------------------------------------------------------------
coalesce(매개변수들) : 왼쪽 매개변수부터 검사해서
		   null이 아닌 최초의 매개변수만 출력			

select salary,commission_pct, coalesce ((commission_pct+1)*salary,salary) from employees;
--------------------------------------------------------------------------------------------------------------
lnnvl
select to_char (commission_pct,'9.99')from employees where lnnvl(commission_pct>=0.2);

nullif(값1,값2) : 값1 == 값2 이면 null출력
	     값1 <> 값2 이면 값1출력
nvl (nullif(값1,값2),'-')

ifnull(값1,값2) <- Mysql


--------------------------------------------------------------------------------------------------------------

decode(칼럼명/표현식, 값1,출력1,값2,출력2,...,값n,출력n)

select decode(channel_id,3,'direct',2,'partners',4,'internet',5,'Catalog',9,'telesale') from sales;
--------------------------------------------------------------------------------------------------------------
기본 집계함수 count sum min max variance stddev

count() -  레코드 개수 세기  count(칼럼명) 할때 값이 null인 칼럼은 포함되지 않는다.
select count(*) from sales;
select count(*) from employees;
select count(*)from products;
select count(*)from channels;


sum(숫자타입 칼럼명) - 합계구하기
select sum(salary)from employees;


avg()- 평균구하기
select avg(salary)from employees;
select to_char(avg(salary),'9999.99')from employees;


min()/max()-최소/최대값
select min(salary),max(salary)from employees;


variance()/stddev()-분산도/표준편차

distinct : 대표값만 표시, ()가 없다.
select distinct salary from employees;

order by 컬럼명1,....,컬럼명n   : 오름차순 정렬(A~Z,a-z,0-9)
order by 컬럼명1,....,컬럼명n desc   : 내림차순 정렬(Z~A,z-a,9-0)

desc=>descendent
asc  =>ascendant

select emp_name from employees order by emp_name;
A부터 오름차순 정렬
select emp_name from employees order by emp_name desc;
내림차순 정렬
select salary,emp_name from employees order by salary,emp_name;
샐러리에서 정렬하고 같은 샐러리 내에서 이름을 또 정렬
--------------------------------------------------------------------------------------------------------------
group by :특정 값을 가진 컬럼 끼리 묶는다. 집계함수(count, sum, avg, min, max, variance, stddev)
	와 반드시 같이 써야한다. 

select job_id,count(*) from employees group by job_id;

select job_id,sum(salary) from employees group by job_id;

select manager_id,count(*) from employees group by manager_id;
매니저사번별 부하직원 숫자 조회

select salary,count(*) from employees group by salary order by salary desc;
월급별 직원숫자 조회+내림차순

select department_id,sum(salary) from employees group by department_id order by department_id;
부서코드별 월급합계


having : group by의 결과에 조건을 추가(집계함수에 대한 조건)

select manager_id,count(*) from employees group by manager_id having count(*)>1;
매니저사번별 부하직원 숫자 조회한거에서 2명 이상 부하직원이 있는경우만 조회

select manager_id,count(*) from employees group by manager_id having count(*)=8;
부하 8명있는 매니저사번만 조회
--------------------------------------------------------------------------------------------------------------
집합연산자



create table exp_goods (
country varchar2(10),seq number,goods varchar2(80)
);
insert into exp_goods values('한국',1,'원유제외석유류');
insert into exp_goods values('한국',2,'자동차');
insert into exp_goods values('한국',3,'전자집적회로');
insert into exp_goods values('한국',4,'선박');
insert into exp_goods values('한국',5,'LCD');
insert into exp_goods values('한국',6,'자동차부품');
insert into exp_goods values('한국',7,'휴대전화');
insert into exp_goods values('한국',8,'환식탄화수소');
insert into exp_goods values('한국',9,'무선송신기디스플레이부속품');
insert into exp_goods values('한국',10,'철또는비합금강');
select * from exp_goods;

create table exp_goods_japan (
country varchar2(10),seq number,goods varchar2(80)
);
insert into exp_goods_japan values('일본',1,'자동차');
insert into exp_goods_japan values('일본',2,'자동차부품');
insert into exp_goods_japan values('일본',3,'전자집적회로');
insert into exp_goods_japan values('일본',4,'선박');
insert into exp_goods_japan values('일본',5,'반도체웨이퍼');
insert into exp_goods_japan values('일본',6,'화물차');
insert into exp_goods_japan values('일본',7,'원유제외석유류');
insert into exp_goods_japan values('일본',8,'건설기계');
insert into exp_goods_japan values('일본',9,'다이오드트랜지스터');
insert into exp_goods_japan values('일본',10,'기계류');
select * from exp_goods_japan;


※ 데이터 타입이 같은 컬럼끼지만 집합연산자가 적용된다

union 합집합 - 공통원소는 한번만 표시 
ex) select goods from exp_goods union select goods from exp_goods_japan;
     select goods from exp_goods union all select goods from exp_goods_japan; 
     union all 은 공통원소 모두 표시

intersect 교집합

ex) select goods from exp_goods intersect select goods from exp_goods_japan;


minus 차집합
ex) select goods from exp_goods minus select goods from exp_goods_japan;

     =>exp_goods(한국)에서 exp_goods_japan(일본)을 뺌
  
    select goods from exp_goods_japan minus select goods from exp_goods;

    => 반대로 일본에서 한국꺼를 뺌


     select goods from exp_goods_japan minus select goods from exp_goods order by goods;
--------------------------------------------------------------------------------------------------------------
기본키(Primary Key):null이 없고 unique한 중복되는 값이 없는 키(휴대전화번호나 주민번호같은거)
외래키(Foreign Key):다른테이블에서 기본키로 사용되고있는 키가 어떠한 다른 테이블에서 검색용키로
		사용되고있을때 그 키를 외래키라고 함




조인 join : 2개 이상의 table을 where조건으로 연계, 새로운 검색 결과를 출력.

※ img1참고

Catasian Join => where조건없이 조인
select a.name,a.mobile,b.phone,b.area
from A, B

이렇게 조인하면 의미없는 데이터도 같이 추출됨



select a.name,a.mobile,b.phone,b.area
from A, B
where A.mobile=B.phone
이렇게 where 까지 넣고 조인해야 의미있는 데이터가 추출


Nomalization :테이블 분리=>작업량 감소의 효과가있음(insert/update/delete)

내부조인(inner join) :
		동등조인(equi) : = 사용해 조인

      select employee_id, emp_name,department_id from employees;

      select department_id, department_name from departments;
 
      select employees.employee_id,employees.emp_name,departments.department_name,
      employees.department_id
      from employees, departments
      where employees.department_id=departments.department_id; 이렇게 하면 너무 기니까

      더 간단하게 쓰려면 이렇게하면된다.
      select a.employee_id,a.emp_name,b.department_name,
      a.department_id
      from employees a, departments b
      where a.department_id=b.department_id;

      select employees.employee_id,employees.emp_name,jobs.job_title
      from employees, jobs
      where employees.job_id=jobs.job_id;
      사번, 이름, 직위명

      select a.employee_id,a.emp_name,b.job_title
      from employees a, jobs b
      where a.job_id=b.job_id;
      간단히쓰기

      select a.employee_id,a.emp_name,b.job_title, C.department_name
      from employees a, jobs b, departments C
      where a.job_id=b.job_id and a.department_id=C.department_id;

      위의 예제에서 departments 테이블의 department_id도 추가 조인하기(and로 묶어줄것)


     select * from sales;
     select * from products;
     select * from customers;
     select * from channels;
     select * from employees;
     이 다섯개의 테이블에서(sales가 기준)

select B.prod_name,C.cust_name,D.channel_desc, E.emp_name
 from sales A, products b, customers C, channels D, employees E
 where A.prod_id=B.prod_id and A.cust_id=C.cust_id and A.channel_id=D.channel_id
 and A.employee_id=E.employee_id;

제품명,고객명,판매방식,판매직원,판매일자 묶어서 조인하기


		세미조인(semi) : <,> 사용해 조인

 select * from departments;
 select * from employees;

 select a.department_id, a.department_name
 from departments a, employees b
 where a.department_id=b.department_id and b.salary>3000
 order by a.department_name;

		안티조인(anti) : != 사용해 조인(동등조인이랑 반대)

		셀프조인(self) : from부분에 같은테이블을 두번 조인 ex) from A, A

 select a.employee_id, a.emp_name, b.emp_name manager_name
 from employees a, employees b
 where A.manager_id=B.employee_id;
a의 manager_id로 b의 employ_id를 셀프조인하여 emp_name중 매니저를 조회

 select a.department_id, a.department_name, b.department_name parent_department
 from departments a, departments b
 where A.parent_id=B.department_id;    
셀프조인으로 상위부서명 조회

--------------------------------------------------------------------------------------------------------------
외부조인(outer join) :

		-left outer join-

 create table a(
 c1 varchar2(4),c2 varchar2(4));
 create table b(
 c3 varchar2(4),c4 varchar2(4));
 insert into a values('1','a');
 insert into a values('2','b');
 insert into a values('3','c');
 insert into a values('4','d');
 insert into a values('5','e');
            
 insert into b values('a','x1');
 insert into b values('c','y1');         
 insert into b values('e','y2');
 insert into b values('a','x2');
 insert into b values('c','y3');
먼저 테이블 생성하고 값 넣은것

 select * from a,b where a.c2=b.c3(+);    
(+)를 붙여주면 내부조인에서 조회안되던 null값도 같이 확인할 수 있다.

mySQL에서는 
select * 
from a left outer join b
on a.c2=b.c3;
이렇게 (+)를 안쓴다 (ANSI style)
 

 select a.employee_id, a.emp_name, b.emp_name manager_name
 from employees a, employees b
 where A.manager_id=B.employee_id(+);
위에 매니저 확인하는 예제에서 스티븐킹만 매니저아이디가 null이라 조회가 안되었는데 (+)붙여주면
같이 조회가 됨

		-right outer join-

(+)를 왼쪽으로 옮기면 right outer join
  select * 
  from a,b
  where a.c2(+)=b.c3;
  select * 
  from b,a
  where b.c3=a.c2(+);

=>둘다똑같음

ansi스타일은
select * 
  from a right outer join b
 on a.c2=b.c3;

select * 
  from b right outer join a
 on b.c3=a.c2;




		-full outer join-

  select * 
  from a,b
 where a.c2(+)=b.c3(+);  => 이렇게 못쓰고 ansi로만 쓸수있다.

ansi 스타일은
  select * 
  from a full outer join b
 on a.c2=b.c3;


select b.emp_name manager_name, count(*)
 from employees a,employees b
 where a.manager_id=b.employee_id
 group by b.emp_name
 order by b.emp_name;
매니저사번 -> 매니저명, 소속직원 숫자(셀프조인 사용)

 select b.department_name,count(*)
from employees a, departments b
where a.department_id=b.department_id
group by b.department_name
order by b.department_name;
부서코드->부서명, 소속직원숫자(동등조인 사용)

 select a.employee_id, a.emp_name, a.salary, b.department_name
 from employees a, departments b
 where a.department_id=b.department_id
and a.salary between 5000 and 10000;     /*    a.salary>=5000 and a.salary <=10000   */
 월급이 5000~10000불 사이인 직원의 직원의 사번 이름 월급 부서명(세미조인활용)











* asterisk (star)
{} brace
<>arrow bracket(홑화살괄호)
[]bracket
~wave
'
"
.
_underscore, underbar
-dash,hyphen
#sharp
&ampersand
^accent, agui
--------------------------------------------------------------------------------------------------------------

select 일반서브쿼리
from 인라인 뷰
where (select * from~) 중첩쿼리

서브쿼리: 위처럼 sql문 안에 하나이상의 sql문이 들어있는경우를 sub-query라고 한다
select 옆에 있으면 일반서브쿼리 from옆에면 인라인 뷰 where 옆이면 중첩쿼리


 select a.employee_id, a.emp_name, a.salary, b.department_name
 from employees a, departments b
 where a.department_id=b.department_id
and a.salary between 5000 and 10000;     
이거를

select a.employee_id,a.emp_name,a.salary,b.department_name 
from (select * from employees where salary between 5000 and 10000) a,
     departments b
where a.department_id=b.department_id;
이런식으로 테이블a를 먼저 5000~10000사이의값으로 잘라주면 sql문이 더 빨라짐

--------------------------------------------------------------------------------------------------------------
select count(*)
from employees
where salary>=(select avg(salary) from employees);
중첩쿼리로 전 사원의 평균 급여 이상을 받는 사원수를 조회

--------------------------------------------------------------------------------------------------------------
select count(*)
from employees
where department_id in(select department_id 
                       from departments 
                       where parent_id is null);

parent_id가 null인 부서번호를 가진 사원의 총 숫자
--------------------------------------------------------------------------------------------------------------
 update employees
 set salary =(select avg(salary) from employees);
모든사원의 급여를 평균 금액으로 갱신
--------------------------------------------------------------------------------------------------------------
delete from employees
where salary<=(select avg(salary) from employees);
평균 급여보다 많이 받는 사원 삭제
--------------------------------------------------------------------------------------------------------------

select employee_id, emp_name, job_id
from employees
where(employee_id,job_id)in (select employee_id,job_id from job_history);

employees의 employee_id,job_id와  job_history의 employee_id,job_id가 일치하는것만 출력



/*제품별 매출액 합계->제품명,매출액 합계*/
select b.prod_name, sum(a.amount_sold)
from sales a, products b
where a.prod_id=b.prod_id
group by b.prod_name
order by sum(a.amount_sold)desc;


/*고객별 매출액 합계 ->고객명, 매출액 합계 */
select b.cust_name, sum(a.amount_sold) total
from sales a, customers b
where a.cust_id=b.cust_id
group by b.cust_name
order by total desc;


/*상위부서가 없는 부서에 속한 직원의 명단, 부서명
이름1 부서명
이름2 부서명 */
 select a.emp_name, b.department_name
from employees a, (select * from departments where parent_id is null) b
where a.department_id=b.department_id;











PLSQL

function : 반환값이 있는 모듈(코드의 묶음)

procedure : 반환값이 없는 모듈

package: 함수와 프로시저를 모아놓은 모듈



PLSQL의 필요이유

-join/Subquery로 해결하지 못하는 연산작업이랑
-주기적으로 반복되는 작업를 위해 나온것이  PLSQ임
-사용자정의 함수를 만들 필요가 있을때 쓴다.

프로그래밍 언어
-변수
-데이터 타입
-연산자
-제어문
-함수
-객체지향특성
 1.캡슐화(class,접근제한자)
 2.상속(extend, implement)
 3.다형성(polymophism)
 4.추상화(interface)


----------------------------------------------------------------------------------------------------------------
PLSQL의 변수선언 

변수명 데이터타입 :=초기값/표현식;

변수명 테이블명.컬럼명%type := 초기값;

상수명 CONSTANT :=상수값;

i integer :=0;


declare
 a INTEGER := 2**2*3**2;

a INTEGER := 2**2*3**2;

vs_emp_name varchar2(80);

c_code char(3);

age number :=12;

name employees.name%type :='John';

pi constant:=3.14

----------------------------------------------------------------------------------------------------------------

연산자

배정연산자
 :=
 --
산술연산자
 +, -, *, /, **,||

비교연산자
 =, <>, != ,>, >=, <, <=, is null, is not null
 --                               -------------------
 between ~ and, in, exists, like
 --------------------------------
논리연산자
not, and, or



/*    */  <=범위주석
--        <=한줄 주석
----------------------------------------------------------------------------------------------------------------
PLSQL의 함수 구조

declare
  변수선언
begin
  실행코드
end;
/


dbms_output.put_line();   =>PLSQL 출력문




declare
  vi_num number;
begin 
  vi_num :=100;
  dbms_output.put_line(vi_num);
end;

출력결과 ==> 100


declare
  vi_num number;
begin 
  vi_num :=-3.14;
  dbms_output.put_line(vi_num);
end;

출력결과 ==> -3.14


declare
  vi_num number;
begin 
  vi_num :=2+5;
  dbms_output.put_line(vi_num);
end;

출력결과 ==> 7


set serveroutput on; 
set timing on;
declare
  vi_num number;
begin 
  vi_num :=3+5;
  dbms_output.put_line(vi_num);
end;
경과시간도 같이 출력



select * from employees;
set serveroutput on; 
set timing on;
declare
  vs_emp_name varchar2(80);
  vs_dep_name varchar2(80);
begin 
  select a.emp_name, b.department_name
  into vs_emp_name, vs_dep_name
  from employees a, departments b
  where a.department_id=b.department_id
  and a.employee_id=100;
  dbms_output.put_line(vs_emp_name||'  -  '||vs_dep_name);
end;

출력 ==> steven king - 기획부
----------------------------------------------------------------------------------------------------------------
PLSQL 제어문


if 비교문 then
    실행문;
elsif 비교문2 then
    실행문;
else
    실행문;
end if;



declare
  vn_salary employees.salary%type;
  vn_did departments.department_id%type;
begin
  select salary into vn_salary
  from employees
  where department_id=90 and rownum=1;
    dbms_output.put_line(vn_salary);
    
  if vn_salary between 1 and 3000 then
    dbms_output.put_line('낮음');
  elsif vn_salary between 3001 and 6000 then
    dbms_output.put_line('중간');
  elsif vn_salary between 6001 and 10000 then
    dbms_output.put_line('높음');
  else
    dbms_output.put_line('최상위'); 
  end if;
  end;
/

==> 24000 최상위




월급이 1000불인 사람 1명의 이름과 부서명
declare
  vs_name employees.emp_name%type;
  vs_dep_name departments.department_name%type;
begin 
  select a.emp_name, b.department_name
  into vs_name, vs_dep_name
  from employees a, departments b
  where a.salary=10000
  and a.department_id=b.department_id 
  and rownum=1;
  dbms_output.put_line(vs_name||'  -  '||vs_dep_name);
end;


----------------------------------------------------------------------------------------------------------------

277p

case표현식  
  when 결과1 then
    실행문1;
  when 결과2 then
    실행문2;
  else
     실행문n;
end case;


 case 
      when salary between 1 and 3000 then
          dbms_output.put_line('낮음');
      when salary between 3001 and 6000 then
          dbms_output.put_line('중간');
      when salary between 6001 and 10000 then 
          dbms_output.put_line('높음');
      else
          dbms_output.put_line('최상위'); 
    end case;
  end;

----------------------------------------------------------------------------------------------------------------
while문

while 조건 
loop
    실행문;
end loop;

0번 이상 실행


declare
 vn_x integer :=1;
 total integer :=0;
 begin
 while vn_x <=100
 loop
  total:=total+vn_x;
  vn_x:=vn_x+1;
  end loop;
  dbms_output.put_line('total='||total);
  end;

1부터 100까지의 합 구하기 total = 5050


 declare
   vn_x integer :=2;
   vn_count integer :=1;
 begin
   while vn_count <=9
   loop
     dbms_output.put_line(vn_x||'*'||vn_count||'='||vn_x*vn_count);
   vn_count:=vn_count+1;
   end loop;
 end;

구구단 2단 출력


----------------------------------------------------------------------------------------------------------------
loop문

loop
   실행문;
   exit when 조건;
   실행문;
end loop;

1번이상 실행


declare
 vn_x integer :=2;
 vn_count integer :=1;
 begin
 loop
     dbms_output.put_line(vn_x||'*'||vn_count||'='||vn_x*vn_count);
   
     vn_count:=vn_count+1;
       exit when vn_count>9;
   end loop;
 end;

구구단 2단 출력

----------------------------------------------------------------------------------------------------------------
for문 281p

for 인덱스변수 in [reverse] 초기값..최종값
loop
  실행문;
end loop;


 for i in 1..9
 loop
 dbms_output.put_line('2x'||i||'='||2*i);
 end loop;


 for i in reverse 10..1
 loop
 dbms_output.put_line('2x'||i||'='||2*i);
 end loop;
 리버스
----------------------------------------------------------------------------------------------------------------
continue 문

declare
 vn_x integer:=2;
begin
 for i in 1..9
 loop 
 continue when i=5;
 dbms_output.put_line(vn_x||'x'||i||'='||vn_x*i);
end loop;
end;

2x5만 스킵한 구구단 2단

----------------------------------------------------------------------------------------------------------------
goto 289p
----------------------------------------------------------------------------------------------------------------
null 284p
----------------------------------------------------------------------------------------------------------------
function 함수

create or replace function 함수명 (
매개변수1 데이터타입,...
,매개변수2 데이터타입)
return (반환값의) 데이터타입
is/as 
  변수,상수 선언부
begin
  실행문
  return 반환값;
end;

함수특징
1. 호출해주는 SQL문이 필요하다



create or replace function showLevel(sal employees.salary%type)
return varchar2
is
   str varchar2(80);
begin
    if sal between 1 and 3000 then
    str:='하위';
    elsif sal between 3001 and 6000 then
    str:='중위';
    elsif sal between 6001 and 10000 then
    str:='상위';
    else 
        str:='최상위';
   end if;
   return str;
   end;
   /


==> Function SHOWLEVEL이(가) 컴파일되었습니다.


select emp_name,salary,showLevel(salary) from employees;
직원들 이름이랑 월급이 하위~최상위 인지 나타내줌

create or replace function getFullName(abbr varchar2)
return countries.country_name%type
is
 strFullName countries.country_name%type:='';
 begin
    select country_name into strFullName
    from countries
    where country_iso_code=abbr;
   return strFullName;
 end;
 /


select country_iso_code,getFullName(country_iso_code)from countries;




부서코드 입력하여 사원이름과 부서명  출력
create or replace function getDname(did varchar2)
return departments.department_name%type
is
 strName departments.department_name%type:='';
 begin
    select department_name into strName
    from departments
    where department_id=did;
   return strName;
 end;
 /
select emp_name,getDname(department_id)from employees;












프로시저

create or replace procedure 프로시저명(
 매개변수1 in/out/in out 데이터타입 [:=기본값]    => default가 in임(아무것도 입력안했을때)
,매개변수n in/out/in out 데이터타입 [:=기본값] )        => default가 in임(아무것도 입력안했을때)
is 
 변수/상수 선언부
begin
 실행문
 [return;]
end;

1.SQL Devleoper/SQL Plus 안에서 execute 프로시저명 <-실행

fucntion/procedure 이름(a number, b varchar2:= ", c number:=0)
이름(10,'x',4)
이름(10) == 이름(10,'',0)
이름(10,'x')==이름(10,'x',0)
이름(10, ,4) 불가






create or replace procedure getSum(did departments.department_id%type :=50)
is 
  strDname departments.department_name%type :='';
  total_sal number:=0;
  howmany number:=0;
begin
  select department_name into strDname
  from departments where department_id=did;
  select sum(salary),count(*)into total_sal, howmany
  from employees
  where department_id=did
  group by department_id;
  dbms_output.put_line('부서명['||strDname||'],총급여['||total_sal||'],총인원수['||howmany||']');
  end;
  /

 exec getSum();

  declare
  begin
  getSum(90);
  end;
   => 프로시저를 코드블럭 내에서 호출할때는 execute문을 사용할 수 없다.


select * from user_source where type='PROCEDURE';


 declare
  begin
   getSum(90);
  end;
이렇게도 실행가능


declare
    strName employees.emp_name%type;
    strDname departments.department_name%type;
  begin
   getSum(90);
   select emp_name,getDname(department_id)
   into strName, strDname
   from employees
   where department_id=90 and rownum=1;
   dbms_output.put_line(strName||'-'||strDname);
  end;
codeblock에서 프로시저 실행하는 방법



---------------------------------------------------------------------------------------------------------
create or replace procedure getDepname(
did in out number, dname out varchar2)
is 
begin 
     select department_name into dname
    from departments
    where department_id=did;
    did:=100;
end;
/


declare
   department_name departments.department_name%type;
   dep_id number :=80;
begin
   getDepname(dep_id, department_name);
   dbms_output.put_line('부서명='||department_name||'['||dep_id||']');
   end;
   /
---------------------------------------------------------------------------------------------------------


예외처리 트랜잭션


Transaction 시작(암묵적)
-SQLPlus/SQL Developer가 실행
-Commit/Rollback 실행 후

Transaction 종료(암묵적)
-SQLPlus/SQL Developer종료 (commit)
-SQLPlus/SQL Developer비정상 종료(Rollback)
=>정전, 윈도우비정상종료

Transaction에 포함되지 않는 SQL문
=> DDL문(Create/Drop/Alter/Truncate/Grant/Revoke)



update 
insert
savepoint a1;
create table <-즉시 실행(Transaction에 포함되지않아 테이블이 사라지지 않는다,텅빈테이블만 남음)
insert
update
delete
savepoint a2;
drop table <-즉시 실행(Transaction에 미포함)
rollback to a2;



savepoint 레이블;
rollback [to 레이블];
commit;

---------------------------------------------------------------------------------------------------------
Exception

declare
begin
   실행문;
   exception when 예외종류 then
      실행문;
   when 예외종류2 then
      실행문;
   when 예외종류n then
      실행문;
end;



declare
 vi_num number:=0;
 begin
  vi_num :=10/0;
  dbms_output.put_line('success');
  
  exception when others then
    dbms_output.put_line('오류발생 -Divided by zero');
    
    
    end;
    /

=> PL/SQL 프로시저가 성공적으로 완료되었습니다.
오류발생 -Divided by zero





declare
 vi_num number:=0;
 begin
  vi_num :=10/0;
  dbms_output.put_line('success');
  
  exception when others then
    dbms_output.put_line('오류발생');
     dbms_output.put_line('sql error code['||sqlcode||']');
         dbms_output.put_line('error message['||sqlerrm||']');
    end;
    /

==> 에러코드랑 에러메세지 추가로 출력 
오류발생 -Divided by zero

오류발생
sql error code[-1476]
error message[ORA-01476: 제수가 0 입니다]




declare
 vi_num number:=0;
 begin
  vi_num :=10/'10';
  dbms_output.put_line('success['||vi_num||']');
  
  exception when others then
    dbms_output.put_line('오류발생');
     dbms_output.put_line('sql error code['||sqlcode||']');
         dbms_output.put_line('error message['||sqlerrm||']');
    end;
    /
==> success

success[1]



사용자정의 익셉션 만들기(user-defined exception

declare
   myExcept exception     
begin
  ...
  if ~ then
    raise myExcept;
  end if;
  ...
  Exception when....then
       실행문;
  when myExcept then
       실행문;
end;
---------------------------------------------------------------------------------------------------------
cursor : SQL실행결과가 저장된 메모리의 특별한 지역
              (select)

묵시적(implicit) 커서 : 자동으로 생성되는 커서
   SQL%FOUND : select 결과로 1개 이상이 조회되면 true, 없으면 false
   SQL%NOTFOUND : select 결과로 없으면 true, 1개 이상이 조회되면 false
   SQL%ROWCOUNT : select 결과의 레코드(row) 갯수 
   SQL%ISOPEN : 


명시적(explicit) 커서 : PL/SQL 코드에 의해 의도적으로 만든 커서




  1. 커서 선언
  2. 커서 열기
  3. 커서에 저장된 데이터 사용
  4. 커서 닫기





declare
 vs_name employees.emp_name%type;
begin
 select emp_name into vs_name from employees
 where manager_id is null;
 if sql%found then
    dbms_output.put_line(vs_name);
   else 
      dbms_output.put_line('찾지 못했습니다.');
      end if;
 end;
 /
=> Steven King


declare
 vs_name employees.emp_name%type;
begin
 select emp_name into vs_name from employees
 where manager_id =10000;
     dbms_output.put_line(vs_name);
     
     exception when others then
        if sql%notfound then
   
      dbms_output.put_line('찾지 못했습니다.');
      end if;
 end;
 /
  
==>찾지 못했습니다.




declare
 vs_name employees.emp_name%type;
begin
 select emp_name into vs_name from employees
 where manager_id is null;
     dbms_output.put_line(vs_name||',인원수['||sql%rowcount||']');
     
     exception when others then
        if sql%notfound then
   
      dbms_output.put_line('찾지 못했습니다.');
      end if;
 end;
 /
 ==> Steven King,인원수[1]




declare
 vs_name employees.emp_name%type;
 cursor c1 (a number, b number)  --1.커서 선언
 is 
   select emp_name from employees where salary between a and b;
begin
 open c1(0,3000);--2.커서 열기
 loop
  fetch c1 into vs_name;  --3. 데이터 사용하기(fetch)
  exit when c1%notfound;
  dbms_output.put_line(vs_name);
 end loop; 
 close c1; --4.커서 닫기
 end;
 /

=>Donald OConnell
Douglas Grant
Shelli Baida
Sigal Tobias
Guy Himuro
Karen Colmenares
Irene Mikkilineni
James Landry
Steven Markle
Mozhe Atkinson
James Marlow
TJ Olson
Michael Rogers
Ki Gee
Hazel Philtanker
John Seo
Joshua Patel
Randall Matos
Peter Vargas
Martha Sullivan
Girard Geoni
Anthony Cabrio
Timothy Gates
Randall Perkins
Vance Jones
Kevin Feeney

select emp_name from employees where salary between 0 and 3000;



***************중요 처음부터 혼자 다시 해볼것***************


/* 부서명, 부서별 인원수, 부서직원의 월급합계 */
select b.department_name, sum(a.salary), count(*)
   from employees a, departments b
   where a.department_id=b.department_id
   group by b.department_name


이거는 그냥 조인 이용해서 sql문으로 찍을수있게 만든 것이고

이것을  커서로 출력하려면


declare
  vs_dname departments.department_name%type;
  total employees.salary%type;
  howmany number;
  cursor c1 is
        select b.department_name, sum(a.salary),count(*)
         from employees a, departments b
        where a.department_id=b.department_id
        group by b.department_name;
begin
  open c1;
  loop
    fetch c1 into vs_dname, total, howmany;
    exit when c1%notfound;
    dbms_output.put_line(vs_dname||','||total||','||howmany);
  end loop;
  close c1;
end;



---------------------------------------------------------------------------------------------------------
--/*employees sales  직원별 매출총액*/

 select a.emp_name, sum(b.amount_sold)
         from employees a, sales b
        where a.employee_id=b.employee_id
        group by a.emp_name;


이걸 커서문으로 출력하면


declare
  vs_name employees.emp_name%type;
  total_sold sales.amount_sold%type;
  cursor c1 is
        select a.emp_name, sum(b.amount_sold)
         from employees a, sales b
        where a.employee_id=b.employee_id
        group by a.emp_name;
        order by sum(b.amount_sold);
begin
  open c1;
  loop
    fetch c1 into vs_name, total_sold;
    exit when c1%notfound;
    dbms_output.put_line(vs_name||','||total_sold);
  end loop;
  close c1;
end;
이렇게하면됨


sql문 부분을 커서를 통해 테이블로 만들수 있다.



-------------------------------------------------------------------------------------------------------
커서+for문 (위보다 간단해진다) ver2



for 변수 in 커서명(매개변수1,...,매개변수n)
loop
   실행문;
end loop;



declare
    cursor c1(x number) is
    select emp_name,department_id
    from employees 
    where manager_id=x;
 begin
   for rec in c1(100)
   loop
     dbms_output.put_line(rec.emp_name||','||rec.department_id);
   end loop;
end;
매니저 아이디가 100인 사람


declare
    cursor c1 is
     select a.emp_name, sum(b.amount_sold) total
         from employees a, sales b
        where a.employee_id=b.employee_id
        group by a.emp_name
        order by sum(b.amount_sold);
 begin
   for rec in c1
   loop
     dbms_output.put_line(rec.emp_name||','||rec.total);
   end loop;
end;
위에서 했던  직원별 매출총액을 ver2 for문을 이용한 커서로 했을경우


-------------------------------------------------------------------------------------------------------
ver3


declare
begin
 for rec in (select emp_name,department_id
               from employees
               where manager_id=100)
 loop
  dbms_output.put_line(rec.emp_name||','||rec.department_id);
end loop;
end;



declare
 begin
   for rec in ( select a.emp_name, sum(b.amount_sold) total
                  from employees a, sales b
                   where a.employee_id=b.employee_id
                   group by a.emp_name
                  order by sum(b.amount_sold)
   ) 
   loop
     dbms_output.put_line(rec.emp_name||','||rec.total);
   end loop;
end;
위에서 했던  직원별 매출총액을 ver3 for문을 이용한 커서로 했을경우



-------------------------------------------------------------------------------------------------------

패키지  

패키지의 프로시저를 불러오려면 execute 패키지명.프로시저명; 이런식으로 하거나
select 패키지명.함수명 from... 함수불러오려면 이렇게 하면됨


..._pkg 패키지명
fn_함수명
proc_프로시저명

----------------------------------------------------------------------------------------------------------
/*입사년도별 인원수 to char, substr, group by*/
select substr(to_char(hire_date,'yyyy-mm-dd'),1,4), count(*)
from employees
group by substr(to_char(hire_date,'yyyy-mm-dd'),1,4)
order by substr(to_char(hire_date,'yyyy-mm-dd'),1,4);



--사원번호,이름,직위명 107명 모두 employees jobs
select employee_id, emp_name, job_title
from employees a full outer join jobs b
on a.job_id=b.job_id;



--부서명, 부서장이름, 부서원 숫자 (이거는 3개의 테이블을 조인해야한다,동등조인,셀프조인)hard
select a.department_name, b.emp_name, count(c.emp_name)
from departments a ,employees b,  employees c
where a.manager_id=b.employee_id and a.department_id=c.department_id
group by a.department_name, b.emp_name;
일단 부서명별 부서장이름을 나타내는 sql문부터 만들고
부서원 총 숫자(count)는 그다음에 추가해서 만들것




--위를 변형시켜 부서명 부서장이름 평균 월급 이상인 부서원숫자 출력-hard
select a.department_name, b.emp_name, count(*)
from departments a ,employees b, 
(select  department_id from employees where salary>=(select avg(salary) from employees))c
where a.manager_id=b.employee_id and a.department_id=c.department_id
group by a.department_name, b.emp_name;



--sales 테이블에서 고객별 상품별 매입액 (고객명 상품명 매입총액)
--john A 100000
--john b  50000
--james A 300000
이런식으로
select b.cust_name,c.prod_name, sum(a.amount_sold)
from sales a , customers b, products c
where a.cust_id=b.cust_id and a.prod_id=c.prod_id
group by b.cust_name,c.prod_name
order by b.cust_name,c.prod_name;



--사장의 직속부하( 매니저아이디가 사장이이디인사람)인 직원이 매니저인 사원 숫자
--직속부하명, 직원숫자
select a.emp_name ,count(*)
from employees a, employees b
where a. manager_id in( select employee_id 
                        from employees 
                        where manager_id is null)
and a.employee_id=b.manager_id
group by a.emp_name;








